Was made of original patch "Allow-building-without-enable_reporting.patch"
From: Zoraver Kang <Zoraver@users.noreply.github.com>
License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html
---
--- a/chrome/browser/net/chrome_report_sender.cc
+++ b/chrome/browser/net/chrome_report_sender.cc
@@ -85,6 +85,7 @@
     const std::string& report,
     base::OnceClosure success_callback,
     ErrorCallback error_callback) {
+  if ((true)) return;
   auto resource_request = std::make_unique<network::ResourceRequest>();
   resource_request->url = report_uri;
   resource_request->method = "POST";
--- a/content/browser/devtools/protocol/network_handler.cc
+++ b/content/browser/devtools/protocol/network_handler.cc
@@ -1290,6 +1290,7 @@
   }
 }
 
+#if 0
 std::vector<GURL> ComputeReportingURLs(RenderFrameHostImpl* frame_host) {
   std::vector<GURL> urls;
   base::queue<FrameTreeNode*> queue;
@@ -1307,6 +1308,7 @@
   }
   return urls;
 }
+#endif
 
 }  // namespace
 
--- a/content/browser/net/cross_origin_embedder_policy_reporter.cc
+++ b/content/browser/net/cross_origin_embedder_policy_reporter.cc
@@ -95,8 +95,8 @@
 void CrossOriginEmbedderPolicyReporter::QueueAndNotify(
     std::initializer_list<std::pair<base::StringPiece, base::StringPiece>> body,
     bool report_only) {
-  const absl::optional<std::string>& endpoint =
-      report_only ? report_only_endpoint_ : endpoint_;
+//  const absl::optional<std::string>& endpoint =
+//      report_only ? report_only_endpoint_ : endpoint_;
   const char* const disposition = report_only ? "reporting" : "enforce";
   if (observer_) {
     std::vector<blink::mojom::ReportBodyElementPtr> list;
@@ -111,6 +111,7 @@
     observer_->Notify(blink::mojom::Report::New(
         kType, context_url_, blink::mojom::ReportBody::New(std::move(list))));
   }
+#if 0
   if (endpoint) {
     base::DictionaryValue body_to_pass;
     for (const auto& pair : body) {
@@ -125,6 +126,7 @@
           /*user_agent=*/absl::nullopt, std::move(body_to_pass));
     }
   }
+#endif
 }
 
 }  // namespace content
--- a/content/browser/net/cross_origin_opener_policy_reporter.cc
+++ b/content/browser/net/cross_origin_opener_policy_reporter.cc
@@ -23,19 +23,19 @@
 namespace {
 
 // Report attribute names (camelCase):
-constexpr char kColumnNumber[] = "columnNumber";
+//constexpr char kColumnNumber[] = "columnNumber";
 constexpr char kDisposition[] = "disposition";
-constexpr char kEffectivePolicy[] = "effectivePolicy";
-constexpr char kInitialPopupURL[] = "initialPopupURL";
-constexpr char kLineNumber[] = "lineNumber";
+//constexpr char kEffectivePolicy[] = "effectivePolicy";
+//constexpr char kInitialPopupURL[] = "initialPopupURL";
+//constexpr char kLineNumber[] = "lineNumber";
 constexpr char kNextURL[] = "nextResponseURL";
-constexpr char kOpeneeURL[] = "openeeURL";
-constexpr char kOpenerURL[] = "openerURL";
-constexpr char kOtherDocumentURL[] = "otherDocumentURL";
+//constexpr char kOpeneeURL[] = "openeeURL";
+//constexpr char kOpenerURL[] = "openerURL";
+//constexpr char kOtherDocumentURL[] = "otherDocumentURL";
 constexpr char kPreviousURL[] = "previousResponseURL";
-constexpr char kProperty[] = "property";
+//constexpr char kProperty[] = "property";
 constexpr char kReferrer[] = "referrer";
-constexpr char kSourceFile[] = "sourceFile";
+//constexpr char kSourceFile[] = "sourceFile";
 constexpr char kType[] = "type";
 
 // Report attribute values:
@@ -44,6 +44,7 @@
 constexpr char kTypeFromResponse[] = "navigation-from-response";
 constexpr char kTypeToResponse[] = "navigation-to-response";
 
+#if 0
 std::string ToString(network::mojom::CrossOriginOpenerPolicyValue coop_value) {
   switch (coop_value) {
     case network::mojom::CrossOriginOpenerPolicyValue::kUnsafeNone:
@@ -59,6 +60,7 @@
       return "same-origin-allow-popups-plus-coep";
   }
 }
+#endif
 
 FrameTreeNode* TopLevelOpener(FrameTreeNode* frame) {
   FrameTreeNode* opener = frame->original_opener();
@@ -229,6 +231,7 @@
     network::mojom::SourceLocationPtr source_location,
     const std::string& reported_window_url,
     const std::string& initial_popup_url) const {
+#if 0
   // Cross-Origin-Opener-Policy-Report-Only is not required to provide
   // endpoints.
   if (!coop_.report_only_reporting_endpoint)
@@ -277,12 +280,14 @@
   storage_partition_->GetNetworkContext()->QueueReport(
       "coop", endpoint, context_url_, reporting_source_, network_isolation_key_,
       absl::nullopt, std::move(body));
+#endif
 }
 
 void CrossOriginOpenerPolicyReporter::QueueNavigationReport(
     base::DictionaryValue body,
     const std::string& endpoint,
     bool is_report_only) {
+#if 0
   body.SetString(kDisposition,
                  is_report_only ? kDispositionReporting : kDispositionEnforce);
   body.SetString(
@@ -291,6 +296,7 @@
   storage_partition_->GetNetworkContext()->QueueReport(
       "coop", endpoint, context_url_, reporting_source_, network_isolation_key_,
       /*user_agent=*/absl::nullopt, std::move(body));
+#endif
 }
 
 }  // namespace content
--- a/content/browser/net/reporting_service_proxy.cc
+++ b/content/browser/net/reporting_service_proxy.cc
@@ -173,6 +173,7 @@
                    const std::string& group,
                    const std::string& type,
                    std::unique_ptr<base::Value> body) {
+#if 0
     auto* rph = RenderProcessHost::FromID(render_process_id_);
     if (!rph)
       return;
@@ -180,6 +181,7 @@
         type, group, url, reporting_source_, network_isolation_key_,
         /*user_agent=*/absl::nullopt,
         base::Value::FromUniquePtrValue(std::move(body)));
+#endif
   }
 
   const int render_process_id_;
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -11328,10 +11328,10 @@
     body.SetString("reason", reason);
 
   // Send the crash report to the Reporting API.
-  GetProcess()->GetStoragePartition()->GetNetworkContext()->QueueReport(
-      /*type=*/"crash", /*group=*/"default", last_committed_url_,
-      GetReportingSource(), isolation_info_.network_isolation_key(),
-      absl::nullopt /* user_agent */, std::move(body));
+  //GetProcess()->GetStoragePartition()->GetNetworkContext()->QueueReport(
+  //    /*type=*/"crash", /*group=*/"default", last_committed_url_,
+  //    GetReportingSource(), isolation_info_.network_isolation_key(),
+  //    absl::nullopt /* user_agent */, std::move(body));
 }
 
 void RenderFrameHostImpl::SendCommitNavigation(
--- a/content/browser/web_package/signed_exchange_reporter.cc
+++ b/content/browser/web_package/signed_exchange_reporter.cc
@@ -127,6 +127,7 @@
 void ReportResult(int frame_tree_node_id,
                   network::mojom::SignedExchangeReportPtr report,
                   const net::NetworkIsolationKey& network_isolation_key) {
+#if 0
   FrameTreeNode* frame_tree_node =
       FrameTreeNode::GloballyFindByID(frame_tree_node_id);
   if (!frame_tree_node)
@@ -141,6 +142,7 @@
   DCHECK(partition);
   partition->GetNetworkContext()->QueueSignedExchangeReport(
       std::move(report), network_isolation_key);
+#endif
 }
 
 }  // namespace
--- a/net/base/features.cc
+++ b/net/base/features.cc
@@ -235,10 +235,10 @@
     "TimeoutTcpConnectAttemptMax",
     base::Seconds(30));
 
-#if BUILDFLAG(ENABLE_REPORTING)
+#if 0
 const base::Feature kDocumentReporting{"DocumentReporting",
                                        base::FEATURE_ENABLED_BY_DEFAULT};
-#endif  // BUILDFLAG(ENABLE_REPORTING)
+#endif
 
 #if BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)
 const base::Feature kUdpSocketPosixAlwaysUpdateBytesReceived{
--- a/net/reporting/reporting_service.cc
+++ b/net/reporting/reporting_service.cc
@@ -211,6 +211,8 @@
       std::unique_ptr<const base::Value> body,
       int depth,
       base::TimeTicks queued_ticks) {
+    if ((true))
+      return;
     DCHECK(initialized_);
     context_->cache()->AddReport(
         reporting_source, network_isolation_key, sanitized_url, user_agent,
--- a/services/network/network_context.h
+++ b/services/network/network_context.h
@@ -445,10 +445,10 @@
       const absl::optional<base::UnguessableToken>& reporting_source,
       const net::NetworkIsolationKey& network_isolation_key,
       const absl::optional<std::string>& user_agent,
-      base::Value body) override;
+      base::Value body);
   void QueueSignedExchangeReport(
       mojom::SignedExchangeReportPtr report,
-      const net::NetworkIsolationKey& network_isolation_key) override;
+      const net::NetworkIsolationKey& network_isolation_key);
   void AddDomainReliabilityContextForTesting(
       const GURL& origin,
       const GURL& upload_url,
--- a/services/network/public/mojom/BUILD.gn
+++ b/services/network/public/mojom/BUILD.gn
@@ -961,7 +961,6 @@
     export_define_blink = "BLINK_PLATFORM_IMPLEMENTATION=1"
     export_header_blink = "third_party/blink/public/platform/web_common.h"
     if (enable_reporting) {
-      enabled_features += [ "enable_reporting" ]
     }
   }
 
--- a/services/network/public/mojom/network_context.mojom
+++ b/services/network/public/mojom/network_context.mojom
@@ -1043,6 +1043,7 @@
   // provided |network_isolation_key|.
   //
   // Spec: https://w3c.github.io/reporting/#concept-reports
+  [EnableIf=enable_reporting]
   QueueReport(string type,
               string group,
               url.mojom.Url url,
@@ -1056,6 +1057,7 @@
   // Note that this queued report will never be delivered if no reporting
   // endpoint matching is registered for with the provided
   // |network_isolation_key|.
+  [EnableIf=enable_reporting]
   QueueSignedExchangeReport(SignedExchangeReport report,
                             NetworkIsolationKey network_isolation_key);
 
--- a/third_party/blink/renderer/core/frame/csp/content_security_policy.cc
+++ b/third_party/blink/renderer/core/frame/csp/content_security_policy.cc
@@ -1056,6 +1056,7 @@
     return;
   }
 
+#if 0
   PostViolationReport(violation_data, context_frame, report_endpoints,
                       use_reporting_api);
 
@@ -1063,6 +1064,7 @@
   // `context_frame` (i.e. we're not processing 'frame-ancestors').
   if (delegate_ && !context_frame)
     delegate_->DispatchViolationEvent(*violation_data, element);
+#endif
 
   AuditsIssue audits_issue = AuditsIssue::CreateContentSecurityPolicyIssue(
       *violation_data, header_type == ContentSecurityPolicyType::kReport,
--- a/third_party/blink/renderer/core/frame/local_frame.cc
+++ b/third_party/blink/renderer/core/frame/local_frame.cc
@@ -2299,9 +2299,9 @@
   return base::UnguessableToken::Null();
 }
 
-mojom::blink::ReportingServiceProxy* LocalFrame::GetReportingService() {
-  return mojo_handler_->ReportingService();
-}
+//mojom::blink::ReportingServiceProxy* LocalFrame::GetReportingService() {
+//  return mojo_handler_->ReportingService();
+//}
 
 // static
 void LocalFrame::NotifyUserActivation(
--- a/third_party/blink/renderer/core/frame/local_frame.h
+++ b/third_party/blink/renderer/core/frame/local_frame.h
@@ -551,7 +551,7 @@
 
   SmoothScrollSequencer& GetSmoothScrollSequencer();
 
-  mojom::blink::ReportingServiceProxy* GetReportingService();
+  //mojom::blink::ReportingServiceProxy* GetReportingService();
 
   // Returns the frame host ptr. The interface returned is backed by an
   // associated interface with the legacy Chrome IPC channel.
--- a/third_party/blink/renderer/core/frame/reporting_context.cc
+++ b/third_party/blink/renderer/core/frame/reporting_context.cc
@@ -53,7 +53,7 @@
 ReportingContext::ReportingContext(ExecutionContext& context)
     : Supplement<ExecutionContext>(context),
       execution_context_(context),
-      reporting_service_(&context),
+      //reporting_service_(&context),
       receiver_(this, &context) {}
 
 // static
@@ -117,7 +117,7 @@
   visitor->Trace(observers_);
   visitor->Trace(report_buffer_);
   visitor->Trace(execution_context_);
-  visitor->Trace(reporting_service_);
+  //visitor->Trace(reporting_service_);
   visitor->Trace(receiver_);
   Supplement<ExecutionContext>::Trace(visitor);
 }
@@ -139,6 +139,7 @@
   UseCounter::Count(execution_context_, feature);
 }
 
+#if 0
 const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
 ReportingContext::GetReportingService() const {
   if (!reporting_service_.is_bound()) {
@@ -148,6 +149,7 @@
   }
   return reporting_service_;
 }
+#endif
 
 void ReportingContext::NotifyInternal(Report* report) {
   // Buffer the report.
@@ -170,6 +172,7 @@
 
 void ReportingContext::SendToReportingAPI(Report* report,
                                           const String& endpoint) const {
+#if 0
   const String& type = report->type();
   if (!(type == ReportType::kCSPViolation || type == ReportType::kDeprecation ||
         type == ReportType::kPermissionsPolicyViolation ||
@@ -225,6 +228,7 @@
         url, endpoint, body->featureId(), body->disposition(), body->message(),
         body->sourceFile(), line_number, column_number);
   }
+#endif
 }
 
 }  // namespace blink
--- a/third_party/blink/renderer/core/frame/reporting_context.h
+++ b/third_party/blink/renderer/core/frame/reporting_context.h
@@ -56,8 +56,8 @@
   // Counts the use of a report type via UseCounter.
   void CountReport(Report*);
 
-  const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
-  GetReportingService() const;
+  //const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
+  //GetReportingService() const;
 
   void NotifyInternal(Report* report);
   // Send |report| via the Reporting API to |endpoint|.
@@ -69,8 +69,8 @@
 
   // This is declared mutable so that the service endpoint can be cached by
   // const methods.
-  mutable HeapMojoRemote<mojom::blink::ReportingServiceProxy>
-      reporting_service_;
+  //mutable HeapMojoRemote<mojom::blink::ReportingServiceProxy>
+  //    reporting_service_;
 
   HeapMojoReceiver<mojom::blink::ReportingObserver, ReportingContext> receiver_;
 };
--- a/third_party/blink/renderer/core/frame/reporting_observer.cc
+++ b/third_party/blink/renderer/core/frame/reporting_observer.cc
@@ -60,8 +60,9 @@
 }
 
 bool ReportingObserver::ObservedType(const String& type) {
-  return !options_->hasTypesNonNull() || options_->typesNonNull().IsEmpty() ||
-         options_->typesNonNull().Find(type) != kNotFound;
+  //return !options_->hasTypesNonNull() || options_->typesNonNull().IsEmpty() ||
+  //       options_->typesNonNull().Find(type) != kNotFound;
+  return false;
 }
 
 bool ReportingObserver::Buffered() {
